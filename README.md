# 1.1. Введение в DevOps — Аронов Леонид
***
## Задание №2 - Описание жизненного цикла задачи (разработки нового функционала)

* ### Формулировка описания нового функционала
  <p>Продукт-менеджер совместно с клиентом или отделом маркетологов формулирует описание нового функционала.</p>
  <p>Реузльтатом их работы является набросок в Figma и словесное описание функционала (use-cases).</p>
* ### Оценка времени реализации нового функционала 
  <p>Проджект-менеджер с помощью тим-лида или непосредственно общаясь с командой разработчиков оценивает время, необходимое на реализацию нового функционала.</p>
  <p>Полученная оценка времени согласуется с продукт-менеджером и клиентом/заказчиком/маркетологами.</p>
* ### Проектирование/доработка текущего проека в части нового функционала
  <p>Проджект-менеджер возможно совместно с тим- и тех-лидом проектирует новый функционал в части входных выходных интерфесов, стараясь не нарушить логику того, что уже есть</p>
  <p>DevOps-инженер согласует с проджект-менеджером инфраструктуру для работы над проектом:
  
    - необходимый набор серверов внутри организации или облачных сервисов;
    - настраивает pipeline, runner'ы и все такое, что позволяет в автоматическом режиме создавать изолированное окружение, его инициализацию, запуск тестов, логирование результатов тестов и мониторинг
    - согласует с командой разработчиков аспекты их работы, затрагивающие CI/CD, чтобы все всё одинаково понимали, помогает им с настройкой среды разработки, снабжает команду разработчиков необходимыми токенами/паролями/ключами/креденшелзами, чтобы они могли выкатывать свой продукт в репозиторгий и pipeline
    - настраивает инфраструктуру в части сохранности рабочего кода (веток/коммитов), возможности отката назад
  </p>
* ### Работа над проектом
  <p>После согласования проджект-менеджер составляет roadmap, планирует первые и следующий спринты, если принята такая модель работы над проектом.</p>
  <p>Команда разработчиком работает по спринтам, а DevOps следят за тем, что настроенная ими инфраструктура позволяет делать то, что должна делать</p>
  <p>DevOps следит за результатами работы команды разработчиков, состоянием всяких секретов, необходимых для dev и prod</p>
  <p>DevOps заряжает свой ноутбук перед сном, чтобы быть готовым в любой момент по логам удаленных серверов перезапустить runner'ы и прочие сервисы автоматизации, прочитать документацию очередного обновления Kubernetes, чтобы вернуть кластер в рабочий режим, или заказать еще мощностей для масштабирования после того, как разработчики выкатили фитчу на тему AR</p>
  <p>DevOps перечитывает книжки дядюшки Боба, чтобы не налепить монстра на кастылях, а сделать все как надо. Ведь инфраструктура - это тоже проект со своей структурой и арзитектурой, все должно быть на своих местах!</p>

* ### Выкат нового функционала потребителю
  <p>Команда разработчиков делает финальный ручной мердж в master, все проходит ожидаеме гладко, срабатывает сценарий выкатки новой версии продукта.</p>
  <p>Пока все работает в автоматическом режиме, DevOps отвечает на вопросы в stackoverflow, сабмитит свои новые идеи разработчикам используемых им инструментов, пишет свои супер-скрипты на питоне или bash, изучает новые инструменты (Pulumi?).</p>


<details>
<summary><strong>P.S.</strong></summary>
Вообще не имея некоторого опыта в области CI/CD, по материалам первого вебинара, на мой взгляд, очень сложно внятно сформулировать аспекты роли devops'а, ведь их надо буквально додумывать самостоятельно, а это уже не обучение, а скорее личный опыт.
Простите за возможно необоснованную критику, может я пока еще что-то не так понимаю, но к концу курса, надеюсь, все пойму и все смогу:)
</details>


# Материалы домашнего задания на тему «2.1. Системы контроля версий.»
1. Добавили что-то в файл README.md и посмотрели на вывода команды
```bash
git status
```
2. Проверили вывод команды `git diff` и `git diff --staged`. Первая выводит разницу между текущим (модифицированным) состоянием файла.
Вторая команда показала разницу между подготовленными к комиту изменениями (staged) и уже закомиченным (в HEAD) состоянием. 
Т.к. новые изменения не были переведены в состояние staged, то вывод был пустой.
3. Добавили изменения в следующий коммит. Теперь вывод команд поменялся: `git diff` не показывает ничего, `git diff --staged` показывает то, что было измененено, но еще не закомичено.

   **Пришлось воспользоваться командой `git rebase`, чтобы вставить коммит в историю версий, т.к. забыл указать сообщение к коммиту в соответствии с заданием. Возникшие конфликты мерджа поправил вручную**
4. Подготовили папку для конфигурации terraform, создали там локальный .gitignore, в котором задали следующие настройки для git'а:
   1. не индексировать подпапки и их содержимое с именем `.terraform` на любом уровне вложенности
   2. не индексировать файлы с расширением `.tfstate` на любом уровне вложенности
   3. не индексировать файлы, в имени которых есть строка `.tfstate.` на любом уровне вложенности
   4. не индексировать файлы с именем crash.log на любом уровне вложенности
   5. не индексировать файлы с расширением `.tfvars` на любом уровне вложенности
   6. не индексировать файлы с именами `override.tf`, `override.tf.json`, а также заканчивающиеся на `_override.tf`, и `_override.tf.json`
   7. не индексировать файлы с именами `.terraformrc` и `terraform.rc`

**Эти настройки работают только относительно папки /terraform и ее подпапок**

# Merge and  Rebase
1. Эксперимент с rebase
2. Приступили к изучению слияний, мержев и ребейза


# Домашнее задание к занятию "3.1. Работа в терминале, лекция 1"

п.8 
- Q1: какой переменной можно задать длину журнала history, и на какой строчке manual это описывается?
  - A1.1: Имя переменной HISTSIZE
  - A1.2: Описание переменной начинается со строки 1178 из 6175

- Q2: что делает директива ignoreboth в bash?
  - A2: HISTCONTROL\
              A colon-separated list of values controlling how commands are saved on the history list.  If the list of values includes ignorespace, lines which begin with a space character are not saved in the history list.  A value
              of ignoredups causes lines matching the previous history entry to not be saved.  A value of ignoreboth is shorthand for ignorespace and ignoredups.  A value of erasedups causes all previous lines matching  the  current
              line to be removed from the history list before that line is saved.  Any value not in the above list is ignored.  If HISTCONTROL is unset, or does not include a valid value, all lines read by the shell parser are saved
              on the history list, subject to the value of HISTIGNORE.  The second and subsequent lines of a multi-line compound command are not tested, and are added to the history regardless of the value of HISTCONTROL.
  - Судя по всему ignoreboth - это ключ, который указывается среди прочих в переменной окружения HISTCONTROL и указывает оболочке не записывать в историю команды, начинающиеся с пробела, а также не дублировать в истории одинаковые команды идущие подряд.

п.9
- Q: В каких сценариях использования применимы скобки {} и на какой строчке man bash это описано?
  - A: { list; }\
              list  is  simply  executed in the current shell environment.  list must be terminated with a newline or semicolon.  This is known as a group command.  The return status is the exit status of list.  Note that unlike the
              metacharacters ( and ), { and } are reserved words and must occur where a reserved word is permitted to be recognized.  Since they do not cause a word break, they must be separated from list by  whitespace  or  another
              shell metacharacter.
  - Это синтаксис для выполнения списка (list) команд в ТЕКУЩЕМ окружении.
  - Описание начинается на строке 196 из 3219

п.10
- Q: С учётом ответа на предыдущий вопрос, как создать однократным вызовом touch 100000 файлов? Получится ли аналогичным образом создать 300000? Если нет, то почему?
  - A1: touch {1..100000}
  - A2: Нельзя. В настройках limits.h через соотношение константы ARG_MAX и размера стека определяется максимальное число допустимых аргументов для функции (так говорит google). Можно поробовать через цикл.

п.11
- Q: В man bash поищите по /\[\[. Что делает конструкция [[ -d /tmp ]]
  - A: `[[ expr ]]` - это проверка `expr` на соответствие True/False. Возвращает 0 или 1. Выражение `-d/tmp` для test проверяет, существует ли файл /tmp и является ли он директорией (опять же без гугла чисто по man, я бы долго доходил до man test).

п.12
- Q: Основываясь на знаниях о просмотре текущих (например, PATH) и установке новых переменных; командах, которые мы рассматривали, добейтесь в выводе type -a bash в виртуальной машине наличия первым пунктом в списке:
```bash
bash is /tmp/new_path_directory/bash
bash is /usr/local/bin/bash
bash is /bin/bash
```
  - A: 
```bash
mkdir -p /tmp/new_path_directory/
cp /usr/local/bin/bash /tmp/new_path_directory/bash
PATH=/tmp/new_path_directory:$PATH
```

п.13
- Q: Чем отличается планирование команд с помощью batch и at?
  - A: `at`      executes commands at a specified time. (запуск команд из файла в определенное время)\
       `batch`   executes commands when system load levels permit; in other words, when the load average drops below 1.5, or the value specified in the invocation of atd. (запуск команд из файла, когда уровень загрузки системы позволяет это сделать). Уровень загрузки системы - это системный показатель, метрика (опять же гугл).


# Домашнее задание к занятию "3.2. Работа в терминале, лекция 2"

Q1: Какого типа команда cd? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.\
A1: 
```bash
type cd
cd is a shell builtin
```
Команда cd - это команда, встроенная в оболочку (shell). Ее назначение - изменять текущую директорию в соответствии с аргументом команда. Оболочка является программой для общения с ядром *'nix. На просторах интернета пишут, что команды, которые так или иначе изменяют состояние оболочки, очевидно, должны быть встроенными (подозреваю, что тут речь о правильном проектировании, области видимости и безопасности). Мои личные соображения: некоторые команды должны быть частью оболочки по принципу "минимального набора инструментов": перейти в директорию, где лежат скрипты, чтобы эти скрипты запустить.

Q2: Какая альтернатива без pipe команде grep <some_string> <some_file> | wc -l? man grep поможет в ответе на этот вопрос. Ознакомьтесь с документом о других подобных некорректных вариантах использования pipe.\
A2: 
```bash
grep -c <some_string> <some_file>
```
Отдельное спасибо за материалы на тему Useless Use of &lt;some bash&gt;.

Q3: Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?\
A3: Это процесс systemd или init (расположение в системе /sbin/init). Вот что говорит про этот процесс man /sbin/init:
- systemd is a system and service manager for Linux operating systems. When run as first process on boot (as PID 1), it acts as init system that brings up and maintains userspace services. Separate instances are started for
       logged-in users to start their services.
- Т.е. это менеджре систем и сервисов. Это тот процесс, который загружается первым при старте Linux. Он инициализирует рабочее окружение (сервисы) каждого пользователя. При этом для каждого залогиневшегося в систему пользователя запускается свой экземпляр сервиса systemd/init.

Q4: Как будет выглядеть команда, которая перенаправит вывод stderr ls на другую сессию терминала?
A4: 
```bash
<'ls' comand use> 2>/dev/ttys003
```
пример для теста
```bash
ls -y 2>/dev/ttys003
```
В этом примере я обращаюсь к команде `ls` с недопустимым ключом `-y` и перенаправляют вывод stderr (его дескриптор - 2) на устройство терминала, которое в моей текущей сессии зарезервировано за терминалом виртуальной машины с сессией Ubuntu.

Q5: Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.\
A5: 
```bash
<comand> file > new_file
```
Пример:
```bash
less file > new_file
```

Q6: Получится ли находясь в графическом режиме, вывести данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?\
A6: Либо я чего-то не понял, либо ответ на этот вопрос дается решением на вопрос №4. Находясь в псевдотерминале (PTY) можно сформировать команду, в которой поток вывода перенаправлен на другое устройство. В качестве этого другого устройства достаточно выбрать соответствующий файл в /dev/tty***. Вопрос только в том, что доступно (область видимости) из текущей сессии. Увидеть результат вывода можно, естественно в том терминале, куда передан вывод, в текущем терминале не будет ничего.

Q7: Выполните команду bash 5>&1. К чему она приведет? Что будет, если вы выполните echo netology > /proc/$$/fd/5? Почему так происходит?\
A7: `bash 5>&1` приводит к созданию в текущей сессисии нового файлового дескриптора с номером 5 (его расположение в системе /proc/$$/fd/5, здесь $$ - это ссылка на процесс текущей сессии). Дополнительно вывод через этот файловый дескриптор перенаправляется на stdout текущей сесси. Поэтому команда `echo netology > /proc/$$/fd/5` просто передает строку `netology` в файловый дескриптор 5, а оттуда строка уже перенаправляется в stdout. Результат тот же, что и от команды `echo netology`.

Q8: Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout команды слева от | на stdin команды справа. Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.\
A8: А зачем тут промежуточный дескриптор? Ведь:
```bash
<comand1> 2>&1 | <comand2>
```
делает все необходимое: через pipe на stdin для command2 поступает stdout и stderr от command1. Я честно пробовал создавать промежуточный файловый дескриптор с перенаправлением на stdout, а потом в него перенаправить stderr при выолнении команды, но тогда данные терялись:()

Q9: Что выведет команда cat /proc/$$/environ? Как еще можно получить аналогичный по содержанию вывод?
A9: Команда выводит перечень переменных окружения и их значения для текущего ($$) процесса. При этом этот перечень соответствует состоянию, когда процесса только запускался. Похожу информацию можно получить, набрав в cmd `env` (/usr/bin/env) с той разницей, что там будут не только те переменные, с которыми была запущена сессия, но новые переменные, определенные во время сессии.

Q10: Используя man, опишите что доступно по адресам /proc/<PID>/cmdline, /proc/<PID>/exe.
A10: 
- По адресу `/proc/<PID>/cmdline` доступно представление команды, с помощью которой порожден процесс с pid=\<PID\>. К зомби-процессам это не относится, для них тут будет пусто (так пишут)
- По адресу `/proc/<PID>/exe` доступна символьная ссылка, содержащаю путь к команде, породившей процесс. То есть по этому адресу можно создать еще одгну копию процесса. 

Q11: Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью /proc/cpuinfo\
A11: 
- sse 
- sse2
- sse4_1
- sse4_2
man говорит, что `lscpu` тоже можно загрепать на этот вопрос.

Q12: При открытии нового окна терминала и vagrant ssh создается новая сессия и выделяется pty. Это можно подтвердить командой tty, которая упоминалась в лекции 3.2. Однако:
```bash
vagrant@netology1:~$ ssh localhost 'tty'
not a tty
```

Почитайте, почему так происходит, и как изменить поведение.

A12: Из того, что видел в интернетах и из того, что встретилось в задаче 4 текущего ДЗ могу сделать такой вывод. При создании ssh сессии в хост-машине выделяется tty и связывается с pty в удаленной машине. Если дальше в удаленной машине попытаться создать еще одну ssh-сессию (соединение), то в рамках текущей ssh-сессии нельзя будет выделить tty, т.к. его там нет.
??: Смущает следующее: ssh localhost позволяет создать-таки ssh-сессию (пришлось подобрать пароль - `vagrant`) и тогда создается еще один pty и в рамках этой вложенной ssh-сессии команжа `tty` честно выдает его pts. И команда `w` тоже показывает два pty. Я подумаю об этом потом.

Q13: Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись reptyr. Например, так можно перенести в screen процесс, который вы запустили по ошибке в обычной SSH-сессии.\
A13: Что-то получилось после правки /etc/sysctl.d/10-ptrace.conf и ребута виртуальной машины. Но кейсы использования утилиты (пришлось его доставлять в виртуалку) неясны даже из матуала:()

Q14: sudo echo string > /root/new_file не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без sudo под вашим пользователем. Для решения данной проблемы можно использовать конструкцию echo string | sudo tee /root/new_file. Узнайте что делает команда tee и почему в отличие от sudo echo команда с sudo tee будет работать.\
A14: 
- sudo echo string > /... = сначала вызвает echo и редирект (т.е. под текущим пользователем, eще не под sudo) и ограничен в доступе к /root
- tee читает stdin и записывает в stdout или файл, соответственно sudo tee выполняется под sudo, поэтому этот процесс уже имеет доступ к /root