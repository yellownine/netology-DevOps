# 1.1. Введение в DevOps — Аронов Леонид
***
## Задание №2 - Описание жизненного цикла задачи (разработки нового функционала)

* ### Формулировка описания нового функционала
  <p>Продукт-менеджер совместно с клиентом или отделом маркетологов формулирует описание нового функционала.</p>
  <p>Реузльтатом их работы является набросок в Figma и словесное описание функционала (use-cases).</p>
* ### Оценка времени реализации нового функционала 
  <p>Проджект-менеджер с помощью тим-лида или непосредственно общаясь с командой разработчиков оценивает время, необходимое на реализацию нового функционала.</p>
  <p>Полученная оценка времени согласуется с продукт-менеджером и клиентом/заказчиком/маркетологами.</p>
* ### Проектирование/доработка текущего проека в части нового функционала
  <p>Проджект-менеджер возможно совместно с тим- и тех-лидом проектирует новый функционал в части входных выходных интерфесов, стараясь не нарушить логику того, что уже есть</p>
  <p>DevOps-инженер согласует с проджект-менеджером инфраструктуру для работы над проектом:
  
    - необходимый набор серверов внутри организации или облачных сервисов;
    - настраивает pipeline, runner'ы и все такое, что позволяет в автоматическом режиме создавать изолированное окружение, его инициализацию, запуск тестов, логирование результатов тестов и мониторинг
    - согласует с командой разработчиков аспекты их работы, затрагивающие CI/CD, чтобы все всё одинаково понимали, помогает им с настройкой среды разработки, снабжает команду разработчиков необходимыми токенами/паролями/ключами/креденшелзами, чтобы они могли выкатывать свой продукт в репозиторгий и pipeline
    - настраивает инфраструктуру в части сохранности рабочего кода (веток/коммитов), возможности отката назад
  </p>
* ### Работа над проектом
  <p>После согласования проджект-менеджер составляет roadmap, планирует первые и следующий спринты, если принята такая модель работы над проектом.</p>
  <p>Команда разработчиком работает по спринтам, а DevOps следят за тем, что настроенная ими инфраструктура позволяет делать то, что должна делать</p>
  <p>DevOps следит за результатами работы команды разработчиков, состоянием всяких секретов, необходимых для dev и prod</p>
  <p>DevOps заряжает свой ноутбук перед сном, чтобы быть готовым в любой момент по логам удаленных серверов перезапустить runner'ы и прочие сервисы автоматизации, прочитать документацию очередного обновления Kubernetes, чтобы вернуть кластер в рабочий режим, или заказать еще мощностей для масштабирования после того, как разработчики выкатили фитчу на тему AR</p>
  <p>DevOps перечитывает книжки дядюшки Боба, чтобы не налепить монстра на кастылях, а сделать все как надо. Ведь инфраструктура - это тоже проект со своей структурой и арзитектурой, все должно быть на своих местах!</p>

* ### Выкат нового функционала потребителю
  <p>Команда разработчиков делает финальный ручной мердж в master, все проходит ожидаеме гладко, срабатывает сценарий выкатки новой версии продукта.</p>
  <p>Пока все работает в автоматическом режиме, DevOps отвечает на вопросы в stackoverflow, сабмитит свои новые идеи разработчикам используемых им инструментов, пишет свои супер-скрипты на питоне или bash, изучает новые инструменты (Pulumi?).</p>


<details>
<summary><strong>P.S.</strong></summary>
Вообще не имея некоторого опыта в области CI/CD, по материалам первого вебинара, на мой взгляд, очень сложно внятно сформулировать аспекты роли devops'а, ведь их надо буквально додумывать самостоятельно, а это уже не обучение, а скорее личный опыт.
Простите за возможно необоснованную критику, может я пока еще что-то не так понимаю, но к концу курса, надеюсь, все пойму и все смогу:)
</details>


# Материалы домашнего задания на тему «2.1. Системы контроля версий.»
1. Добавили что-то в файл README.md и посмотрели на вывода команды
```bash
git status
```
2. Проверили вывод команды `git diff` и `git diff --staged`. Первая выводит разницу между текущим (модифицированным) состоянием файла.
Вторая команда показала разницу между подготовленными к комиту изменениями (staged) и уже закомиченным (в HEAD) состоянием. 
Т.к. новые изменения не были переведены в состояние staged, то вывод был пустой.
3. Добавили изменения в следующий коммит. Теперь вывод команд поменялся: `git diff` не показывает ничего, `git diff --staged` показывает то, что было измененено, но еще не закомичено.

   **Пришлось воспользоваться командой `git rebase`, чтобы вставить коммит в историю версий, т.к. забыл указать сообщение к коммиту в соответствии с заданием. Возникшие конфликты мерджа поправил вручную**
4. Подготовили папку для конфигурации terraform, создали там локальный .gitignore, в котором задали следующие настройки для git'а:
   1. не индексировать подпапки и их содержимое с именем `.terraform` на любом уровне вложенности
   2. не индексировать файлы с расширением `.tfstate` на любом уровне вложенности
   3. не индексировать файлы, в имени которых есть строка `.tfstate.` на любом уровне вложенности
   4. не индексировать файлы с именем crash.log на любом уровне вложенности
   5. не индексировать файлы с расширением `.tfvars` на любом уровне вложенности
   6. не индексировать файлы с именами `override.tf`, `override.tf.json`, а также заканчивающиеся на `_override.tf`, и `_override.tf.json`
   7. не индексировать файлы с именами `.terraformrc` и `terraform.rc`

**Эти настройки работают только относительно папки /terraform и ее подпапок**
 
added for test
